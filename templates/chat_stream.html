<!-- Streaming Bot Response Container -->
<!-- Uses native EventSource for reliable streaming with Markdown rendering -->
<div id="message-{{ msg_index }}" class="message-container flex flex-col gap-2 mb-4 items-start"
    data-msg-index="{{ msg_index }}" data-sender="bot">

    <div id="message-bubble-{{ msg_index }}"
        class="max-w-[80%] bg-zinc-900 text-zinc-100 rounded-t-2xl rounded-br-2xl p-2">
        <!-- Streaming content target -->
        <div id="stream-content-{{ stream_id }}" class="text-sm leading-relaxed markdown-content">
            {{ message if message else '' }}<span class="stream-cursor animate-pulse text-blue-400">▋</span>
        </div>
    </div>

    <!-- Edit Mode (Initially Hidden) -->
    <div id="edit-container-{{ msg_index }}" class="hidden w-full max-w-[80%] self-start">
        <textarea id="edit-textarea-{{ msg_index }}"
            class="w-full bg-zinc-800 text-white text-sm p-3 rounded-xl border border-blue-500 outline-none resize-none min-h-[100px]"></textarea>
        <div class="flex gap-2 mt-2 justify-start">
            <button class="px-3 py-1 text-sm bg-zinc-700 hover:bg-zinc-600 text-gray-300 rounded-lg transition-colors"
                _="on click
                    add .hidden to #edit-container-{{ msg_index }}
                    remove .hidden from #message-bubble-{{ msg_index }}
                    remove .hidden from <.message-actions/> in #message-{{ msg_index }}">Cancel</button>
            <button class="px-3 py-1 text-sm bg-blue-600 hover:bg-blue-500 text-white rounded-lg transition-colors"
                hx-patch="/chat/{{ conversation_id }}/message/{{ msg_index }}" hx-ext="json-enc"
                hx-vals='js:{"content": document.getElementById("edit-textarea-{{ msg_index }}").value}'
                hx-target="#new-messages" hx-swap="innerHTML">Save</button>
        </div>
    </div>

    <!-- Action buttons - shown when streaming completes -->
    <div id="stream-actions-{{ stream_id }}" class="message-actions hidden"></div>
</div>

<script>
    (function () {
        const streamId = "{{ stream_id }}";
        const convId = "{{ conversation_id }}";
        const contentEl = document.getElementById('stream-content-' + streamId);
        const actionsEl = document.getElementById('stream-actions-' + streamId);

        if (!contentEl) return;

        // Track accumulated raw content - initialized from server-side state
        let rawAccumulated = {{ (message if message else '') | tojson
    }};

    // Create EventSource connection for SSE streaming
    const eventSource = new EventSource('/chat/' + convId + '/bot-stream');

    // Helper to update UI with rendered content and maintain cursor
    const updateUI = (text) => {
        contentEl.textContent = text;
        if (window.renderMessageStreaming) {
            window.renderMessageStreaming(contentEl);
        }

        const cursor = document.createElement('span');
        cursor.className = 'stream-cursor animate-pulse text-blue-400';
        // cursor.textContent = '▋';
        contentEl.appendChild(cursor);

        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    };

    // Initial render if resuming
    if (rawAccumulated) {
        updateUI(rawAccumulated);
    }

    // Handle token events - each event contains the full accumulated text so far
    eventSource.addEventListener('token', function (evt) {
        try {
            rawAccumulated = JSON.parse(evt.data);
        } catch (e) {
            rawAccumulated = evt.data;
        }
        updateUI(rawAccumulated);
    });

    // Handle done event - streaming complete
    eventSource.addEventListener('done', function (evt) {
        eventSource.close();

        // Final full render with all features
        contentEl.textContent = rawAccumulated;
        if (window.renderMessage) {
            window.renderMessage(contentEl);
        }

        // Populate edit textarea
        const editTextarea = document.getElementById('edit-textarea-{{ msg_index }}');
        if (editTextarea) {
            editTextarea.value = rawAccumulated;
        }

        // Show action buttons
        try {
            actionsEl.innerHTML = JSON.parse(evt.data);
        } catch (e) {
            actionsEl.innerHTML = evt.data;
        }
        actionsEl.classList.remove('hidden');

        if (window._hyperscript) {
            window._hyperscript.processNode(actionsEl);
        }

        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    });

    // Handle errors
    eventSource.addEventListener('error', function (evt) {
        eventSource.close();
        console.error('SSE Error:', evt);
    });
    }) ();
</script>